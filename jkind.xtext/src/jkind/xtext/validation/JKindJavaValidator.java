/*
 * generated by Xtext
 */
package jkind.xtext.validation;

import java.math.BigInteger;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

import jkind.lustre.values.IntegerValue;
import jkind.lustre.values.RealValue;
import jkind.lustre.values.Value;
import jkind.xtext.jkind.ArrayAccessExpr;
import jkind.xtext.jkind.ArrayType;
import jkind.xtext.jkind.Assertion;
import jkind.xtext.jkind.BinaryExpr;
import jkind.xtext.jkind.CastExpr;
import jkind.xtext.jkind.Constant;
import jkind.xtext.jkind.EnumType;
import jkind.xtext.jkind.EnumValue;
import jkind.xtext.jkind.Equation;
import jkind.xtext.jkind.Expr;
import jkind.xtext.jkind.Field;
import jkind.xtext.jkind.File;
import jkind.xtext.jkind.IdExpr;
import jkind.xtext.jkind.JkindPackage;
import jkind.xtext.jkind.Node;
import jkind.xtext.jkind.Property;
import jkind.xtext.jkind.RecordExpr;
import jkind.xtext.jkind.SubrangeType;
import jkind.xtext.jkind.TypeDef;
import jkind.xtext.jkind.UnaryExpr;
import jkind.xtext.jkind.Variable;
import jkind.xtext.jkind.VariableGroup;
import jkind.xtext.typing.JArrayType;
import jkind.xtext.typing.JType;
import jkind.xtext.typing.TypeChecker;
import jkind.xtext.util.Util;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.ComposedChecks;

import com.google.inject.Inject;

@ComposedChecks(validators = { TypesAcyclicValidator.class, NodesAcyclicValidator.class,
		EquationsAcyclicValidator.class, ConstantsAcyclicValidator.class })
public class JKindJavaValidator extends AbstractJKindJavaValidator {
	@Inject
	protected IValidatorAdvisor validationOptions;

	@Check
	public void checkEquationType(Equation equation) {
		new TypeChecker(getMessageAcceptor()).check(equation);
	}

	@Check
	public void checkAssertionType(Assertion assertion) {
		new TypeChecker(getMessageAcceptor()).check(assertion);
	}

	@Check
	public void checkPropertyType(Property property) {
		new TypeChecker(getMessageAcceptor()).check(property);
	}

	@Check
	public void checkConstantType(Constant constant) {
		new TypeChecker(getMessageAcceptor()).check(constant);
	}

	@Check
	public void checkNoGlobalShadowing(File file) {
		Set<String> globals = new HashSet<>();

		for (TypeDef def : file.getTypedefs()) {
			if (def instanceof EnumType) {
				EnumType et = (EnumType) def;
				for (EnumValue ev : et.getValues()) {
					globals.add(ev.getName());
				}
			}
		}

		for (Constant c : file.getConstants()) {
			globals.add(c.getName());
		}

		for (Node node : file.getNodes()) {
			for (Variable v : Util.getNodeVariables(node)) {
				if (globals.contains(v.getName())) {
					error("Variable name shadows global name", v);
				}
			}
		}
	}

	@Check
	public void checkSubrangeNonempty(SubrangeType subrangeType) {
		if (subrangeType.getLow().compareTo(subrangeType.getHigh()) > 0) {
			error("Subrange must be non-empty");
		}
	}

	@Check
	public void checkArrayNonempty(ArrayType arrayType) {
		if (arrayType.getSize().equals(BigInteger.ZERO)) {
			error("Array must be non-empty");
		}
	}

	@Check
	public void checkConstantHasConstantValue(Constant constant) {
		if (!isConstant(constant.getExpr())) {
			error(constant.getName() + " does not have constant value");
		}
	}

	private Boolean isConstant(Expr expr) {
		return new ConstantAnalyzer().doSwitch(expr);
	}

	private Value evalConstant(Expr expr) {
		return new ConstantEvaluator().doSwitch(expr);
	}

	private JType getType(Expr expr) {
		return new TypeChecker(getMessageAcceptor()).doSwitch(expr);
	}

	@Check
	public void checkArrayAccessBounded(ArrayAccessExpr e) {
		try {
			if (isConstant(e.getIndex())) {
				IntegerValue iv = (IntegerValue) evalConstant(e.getIndex());
				JArrayType arrayType = (JArrayType) getType(e.getArray());
				if (iv.value.compareTo(BigInteger.ZERO) < 0
						|| iv.value.compareTo(BigInteger.valueOf(arrayType.size)) >= 0) {
					error("Index " + iv.value + " out of bounds", e.getIndex());
				}
			}
		} catch (ClassCastException ignore) {
			// Already flagged by type checker
		}
	}

	@Check
	public void checkRecordExprFieldsUnique(RecordExpr record) {
		Set<Field> seen = new HashSet<>();
		Set<Field> marked = new HashSet<>();
		for (Field field : record.getFields()) {
			if (seen.contains(field) && !marked.contains(field)) {
				marked.add(field);
				errorDuplicateField(record, field);
			}
			seen.add(field);
		}
	}

	private void errorDuplicateField(RecordExpr record, Field field) {
		for (int i = 0; i < record.getFields().size(); i++) {
			if (record.getFields().get(i).equals(field)) {
				error("Duplicate field " + field.getName(), record,
						JkindPackage.Literals.RECORD_EXPR__FIELDS, i);
			}
		}
	}

	@Check
	public void checkNodeVariableAssignments(Node node) {
		List<Variable> assigned = new ArrayList<>();
		List<Variable> toAssign = new ArrayList<>();
		for (VariableGroup group : node.getOutputs()) {
			toAssign.addAll(group.getVariables());
		}
		for (VariableGroup group : node.getLocals()) {
			toAssign.addAll(group.getVariables());
		}

		for (Equation eq : node.getEquations()) {
			for (int i = 0; i < eq.getLhs().size(); i++) {
				Variable var = eq.getLhs().get(i);
				if (assigned.contains(var)) {
					error("Variable " + var.getName() + " already assigned", eq,
							JkindPackage.Literals.EQUATION__LHS, i);
				} else if (!toAssign.contains(var) && var.getName() != null) {
					error("Input variable " + var.getName() + " cannot be assigned", eq,
							JkindPackage.Literals.EQUATION__LHS, i);
				}
				assigned.add(var);
				toAssign.remove(var);
			}
		}

		for (Variable var : toAssign) {
			error("Variable " + var.getName() + " is not assigned", var);
		}
	}

	@Check
	public void checkNodeVariableUse(Node node) {
		List<Variable> toUse = new ArrayList<>();
		for (VariableGroup group : node.getInputs()) {
			toUse.addAll(group.getVariables());
		}
		for (VariableGroup group : node.getLocals()) {
			toUse.addAll(group.getVariables());
		}

		for (IdExpr idExpr : EcoreUtil2.getAllContentsOfType(node, IdExpr.class)) {
			toUse.remove(idExpr.getId());
		}
		for (Property property : node.getProperties()) {
			toUse.remove(property.getRef());
		}

		for (Variable var : toUse) {
			warning("Variable " + var.getName() + " is not used", var);
		}
	}

	@Check
	public void checkPropertiesUnique(Node node) {
		Set<Variable> seen = new HashSet<>();
		for (Property property : node.getProperties()) {
			Variable variable = property.getRef();
			if (seen.contains(variable)) {
				error(variable.getName() + " already declared as property", property);
			}
			seen.add(variable);
		}
	}

	@Check
	public void checkLinear(BinaryExpr e) {
		switch (e.getOp()) {
		case "*":
			if (!isConstant(e.getLeft()) && !isConstant(e.getRight())) {
				if (validationOptions.allowNonlinear()) {
					warning("Nonlinear multiplication");
				} else {
					error("Nonlinear multiplication not supported");
				}
			}
			break;

		case "/":
		case "div":
			if (!isConstant(e.getRight())) {
				if (validationOptions.allowNonlinear()) {
					warning("Nonlinear division");
				} else {
					error("Non-constant division not supported");
				}
			}
			break;
		}
	}

	@Check
	public void checkDivideByZero(BinaryExpr e) {
		try {
			if (e.getOp().equals("/")) {
				RealValue value = (RealValue) evalConstant(e.getRight());
				if (value.value.signum() == 0) {
					error("Division by zero");
				}
			}

			if (e.getOp().equals("div")) {
				IntegerValue value = (IntegerValue) evalConstant(e.getRight());
				if (value.value.signum() == 0) {
					error("Division by zero");
				} else if (value.value.signum() < 0) {
					error("Integer division by negative values is disabled");
				}
			}

			if (e.getOp().equals("mod")) {
				IntegerValue value = (IntegerValue) evalConstant(e.getRight());
				if (value.value.signum() == 0) {
					error("Modulus by zero");
				} else if (value.value.signum() < 0) {
					error("Modulus by negative values is disabled");
				}
			}
		} catch (ClassCastException ignore) {
			// Already flagged by type checker
		}
	}

	@Check
	public void checkUnusedAssertion(Assertion e) {
		Node node = EcoreUtil2.getContainerOfType(e, Node.class);
		if (!isMainNode(node)) {
			warning("Assertion in non-main node is ignored");
		}
	}

	@Check
	public void checkMainAnnotation(Node node) {
		if (!node.getMain().isEmpty() && !isMainNode(node)) {
			warning("Node " + node.getName() + " marked as main, but is not treated as main node",
					node, JkindPackage.Literals.NODE__MAIN);
		}
	}

	private boolean isMainNode(Node node) {
		File file = EcoreUtil2.getContainerOfType(node, File.class);
		return node.equals(Util.getMainNode(file));
	}

	@Check
	public void checkUnguardedPre(UnaryExpr e) {
		if (e.getOp().equals("pre")) {
			Expr curr = e;
			while (curr.eContainer() instanceof Expr) {
				Expr parent = (Expr) curr.eContainer();
				if (parent instanceof BinaryExpr) {
					BinaryExpr be = (BinaryExpr) parent;
					if (be.getOp().equals("->") && be.getRight().equals(curr)) {
						// Guarded
						return;
					}
				} else if (parent instanceof UnaryExpr) {
					UnaryExpr ue = (UnaryExpr) parent;
					if (ue.getOp().equals("pre")) {
						// Unguarded
						break;
					}
				}
				curr = parent;
			}
			warning("Possible unguarded pre expression");
		}
	}

	@Check
	public void checkModDiv(BinaryExpr e) {
		switch (e.getOp()) {
		case "mod":
		case "div":
			if (validationOptions.isYices2() || validationOptions.isMathSat()) {
				error(validationOptions.getSolverName() + " does not support " + e.getOp(), e);
			}
		}
	}

	@Check
	public void checkCast(CastExpr e) {
		if (validationOptions.isYices2()) {
			error(validationOptions.getSolverName() + " does not support casting", e);
		}
	}

	private void error(String message) {
		error(message, null);
	}

	private void error(String message, EObject source) {
		error(message, source, null);
	}

	private void warning(String message) {
		warning(message, null);
	}

	private void warning(String message, EObject source) {
		warning(message, source, null);
	}
}
