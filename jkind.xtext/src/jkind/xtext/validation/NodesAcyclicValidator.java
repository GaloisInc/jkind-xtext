/*
 * generated by Xtext
 */
package jkind.xtext.validation;

import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import jkind.util.CycleFinder;
import jkind.xtext.jkind.CallExpr;
import jkind.xtext.jkind.File;
import jkind.xtext.jkind.JkindPackage;
import jkind.xtext.jkind.Node;
import jkind.xtext.util.Util;

import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.validation.EValidatorRegistrar;

public class NodesAcyclicValidator extends AbstractJKindJavaValidator {
	@Check
	public void checkAcyclic(File file) {
		Map<String, Set<String>> dependencies = getDependencies(file);
		List<String> cycle = CycleFinder.findCycle(dependencies);
		if (cycle != null) {
			error(file, cycle);
		}
	}

	protected Map<String, Set<String>> getDependencies(File file) {
		Map<String, Set<String>> dependencies = new HashMap<>();
		for (Node node : file.getNodes()) {
			Set<String> set = new HashSet<>();
			for (CallExpr call : EcoreUtil2.getAllContentsOfType(node, CallExpr.class)) {
				if (call.getCallable() instanceof Node) {
					set.add(call.getCallable().getName());
				}
			}
			dependencies.put(node.getName(), set);
		}
		return dependencies;
	}

	protected void error(File file, List<String> cycle) {
		String message = "Cycle in node calls " + Util.getCycleErrorMessage(cycle);
		Map<String, Node> table = getNodeTable(file);
		boolean first = true;
		for (String node : cycle) {
			if (first) {
				first = false;
			} else {
				error(message, table.get(node), JkindPackage.Literals.CALLABLE__NAME);
			}
		}
	}

	private Map<String, Node> getNodeTable(File file) {
		Map<String, Node> table = new HashMap<>();
		for (Node node : file.getNodes()) {
			table.put(node.getName(), node);
		}
		return table;
	}

	@Override
	public void register(EValidatorRegistrar registrar) {
		// Since this is a composed check we prevent it from registering on its
		// own
	}
}
